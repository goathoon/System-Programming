# System-Programming
- - - 

# 2022년 1학기 우홍욱 교수님 시스템 프로그래밍 sfp 구현

## 과제 목적
컴퓨터에서의 floating point에 대한 이해 및 sfp 구현

## int2sfp 함수
특수한 상황들인 input = 0일 때, input이 sfp 최대값 초과일때, 최소값 미만일때는 맨 앞줄 코드와 맨 뒷줄코드를
참조하면 된다. 최대값 초과 일 때에는, 1.111111111* 2^15 보다 클 때이므로, 이는 곧 2^16 -32 와 같다. 따라서
이에 맞게끔 if문을 써주어서 return 되는 값을 무한대(31<10)로 설정, 그리고 최소값 미만일 때도 같은 방식으로
하였다.
일반적인 상황에서는 int값을 sfp로 나타내기 위해서 input이 양수 ,음수일 때의 상황을 나누어 코드를 작성하였
고, 이는 각각 return 되는 sfp값에 1<<15 를 더하냐 더하지 않느냐의 차이이다. sfp의 frac 부분과 exp부분을 뽑
아내기 위해 적절한 변수들을 설정하였고, frac을 구하기 위해서 input을 계속해서 2로나눈 나머지를 frac임시 배
열에 저장한 후, 알맞은 frac 배열을 얻어내기 위해 for문으로 frac임시배열의 값을 거꾸로 돌렸다. 그리고 , sfp값
에 알맞은 수로 변환하기 위하여 , 비트연산자를 활용해 구하였다. 이 때, 10비트 이상의 비트가 필요한 경우에,
가장 비트를 한칸씩 뒤로 당기는 for문을 작성하여, 값에 영향력을 더 많이 끼치는 10비트로 만들었다. 이는 곧 round
to zero방식을 활용한 것이다.

## sfp2int 함수
Sfp의 값을 int로 돌리기 위해서 비트연산자를 활용하여 sign bit이 뭔지, exp bit이 뭔지, frac bit이 뭔지 구해내었
고, 특이한 사항에 맞는 값들(exp=31이 됐을때)에 따라 적절하게 return값으로 반환하였다.
앞서 구한 bit를 활용하여 반환값이 어떤 값이 되는지 비트연산자를 활용해 얻어낼 수 있었다. 이때 leading ‘1’이
포함되어 있다는 사실에 유의하며 계산하였다. 이때 혹여나 반환값이 float로 나오더라도 함수 자체가 int반환
함수이기 때문에 알아서 round to zero의 형식을 구현한다.

## float2sfp 함수
소수점 아래부분과, 정수부분을 따로 구분하여야 했다. 특수한 상황들일 때에는 int2sfp와 비슷한 코드로 전개하
였다.
일반적인 상황에서, input값이 양수인지 음수인지 알기위해, integer>>15 == 0 , ~integer>>15==0의 조건문을 활
용하였다. 각각의 상황속에서 정수부와 소수부를 저장하는 임시배열을 선언하고, 반복문을 활용하여 정수부분이
1이상일 때 2의 지수부를 구하고 정수부 임시배열을 구하고, 소수부 임시배열을 구하였다. 이 때, 가수부분이 반
드시 10자리가 되어야 하므로, 정수부분과 소수부분의 개수들의 합이 10을 넘겨서는 안된다. 또한, 정수부분이
10비트이상이 되버리면, 아래비트는 전혀 필요가 없어지게 된다. 이때, 더 큰 값을 나타내는
10비트 이외의 비트는 무시하면 된다.(round to zero). 이에 유의하면서 각각의 임시배열에 적절한
값들을 저장하였다. 정수부분이 0 일때에는 지수부의 재조정이 필요했다. 0으로 초기화 했 던 초기상태에서
지수를 낮춰가며 조정할 필요가 있었다. 2의 지수부를 구하기 위해서 반복문을 활용하였고, 지수 부가 -15 아래이면
denormalized의 경우이므로, 이때, input 값이 0에 엄청나게 가까운 수이면 0을 출력하게 하였 다. Normalized
value들의 경우에는 지수부가 -15가 되기 이전까지 무조건 지수부가 나온다. 이를 dec_below 즉, 소수점 아래의
수를 0.5로 나누고, 그때 1로 나누어 떨어지지 않으면 다시 0.25로나누고 다음은 0.125로 나누는 식으로
반복문을 돌려서 지수부를 찾았다. 그 후에는 어차피 정수부는 없으므로, 소수부의 가수부분 개수만 카운팅하면 된다.
마찬가지로 여기서도 소수부만 10비트가 나올 수 있으므로, 이에 유의하였다.그리고 앞서 했던
방식과 동일하게 소수부분의 수들 임시 소수배열에 저장하였다.
배열에 저장을 마친 후에는, 각각의 배열을 알맞은 위치에 재정렬시켜야 하므로, for문을 활용하여 frac 실제
배열에 재정렬 하였다. 그리고 int2sfp 에서 sfp의 값을 반환한 것 과 비슷하게 sfp의 값을 계산하였다. Input이
음수일 때에는,
‘음수’임에 유의하여서 같은 방식으로 진행하였다.

## sfp2float 함수
특수한 상황의 경우 exp =31인 경우 frac부분의 비트에 따라서, 무한대 혹은 NaN을 return 하였다.
sfp를 float으로 바꾸기 위해서 각각의 비트들을 나타내는 수들을 선언하였다. frac부분이 나타내는 수를 알아내기
위하여 fracBit 배열을 선언하였고, 실제 frac부분에 들어가는 비트의 순서에 맞게 정렬하였다. 이러면 계산이 용
이할 것이다.
일반적인 상황에서, exp-15가 0보다 크냐 작냐에 따라 sfp값을 계산하는 값이 달라지므로, 그 경우를 나누어 주었
고, fracBit을 for문으로 하나하나 참조하며, exp-15 (즉 2의 지수부)에 맞게끔 계산하는 과정을 거쳤다.

## sfp_add 함수
매개변수의 수들이 음수인지 양수인지 먼저 구분하고, 각각의 signbit과 exp, frac부분을 다 구해내었다.
먼저 예외사항들을 처리해주었다. 이때 NaN같은 경우 (31<<10) + 1로 반환하였다.
덧셈을 위해서는 지수부를 맞춰주어야 하므로, 어떤 매개변수가 지수부가 큰지 확인해야 한다. 따라서
a 와 b의 지수부를 비교하는 과정을 거치는 조건문을 제시하였다.
먼저 a가 b보다 지수부가 큰 경우에는, b의 지수부를 a의 지수부에 맞추어야 한다. 이를 위해 exp_b (b의 지수부)
를 하나씩 증가시키고, b의 fracbit을 1만큼 오른쪽으로 옮겨야한다. 이때, 버려지는 비트들은 따로 저장해야만 한
다. 이전 함수들에는 어차피 round to zero 라운딩이라 상관없이 버려도 되지만, 이 함수는 round to even 이라서
버려지는 수들의 합이 필요하기 때문이다. 따라서 이를 위한 변수 rounding을 선언하고 이들을 저장하였다.
rounding 즉 버려지는 수들의 합이 1보다 크다면, 이 앞의 비트 (만약에 11011이라는 이진법의 수가 있는데, 뒤
의 11이 버려진다면, rounding에 3이저장된다. 이는 ‘0’이 들어있는 세번째 자리숫자가 의미하는 수인 4의 반보다
크냐 작냐에 따라서 rounding이 결정되는 비트)의 반보다 크냐 작냐에 따라서 올릴건지 버릴건지 결정한다. 만약
딱 반이라면 frac의 마지막비트가 홀수인지 양수인지 따지고 결정하면 된다.
지수부를 맞추었으면, a의 부호 b의 부호에 따라 계산양상이 달라질 것이다. 이를 조건문으로 제시하였다. a와 b
가 같은 부호일 때는 다소 쉽다. 그냥 frac_a와 frac_b를 더하고, 만약 frac에서 정수부분이 생긴다면, exp를 늘리
고,(지수부를 늘리고) 하는 방식으로 진행하면 된다. 이는 frac_a와 frac_b 의 합이 2^10으로 나누었을 때 2 이상
인 경우이므로, 조건문으로 제시한 후 처리했다. 이 때도 마찬가지로, fracbit이 오른쪽으로 한번 움직이므로, 버려
지는 비트를 어떻게 처리할 것인지 round to even 방식에 따라서 결정하면 된다. 이 때 frac부분이 1로만 이루어
져 있다면 또다시 overflow가 발생할 수 있기 때문에 이를 처리하는 과정도 작성하였다.
a와 b의 부호가 다를 때에는, 절대값이 큰 쪽에서 작은 쪽의 frac부분을 뺀다. 이 때에도 leading ‘1’의 존재를 의식
하면서 진행한다.
a의 지수부보다 b의 지수부보다 큰 경우에는 아까와 반대로 해주면 되고, a와 b의 지수부가 같을 때에는 또 처리
방식이 다르다. 이 때에는, leading 1끼리의 합이 무조건 2가되므로, exp 증가가 필수이다. 이에 유의하면서 이 전과
같은 방식으로 진행하였다.

## sfp_mul 함수
sfp_add 와 비슷하게 매개변수 각각의 bit를 나타내는 수들을 저장하고, 각각의 부호에 따라서 곱의 부호는 결정
되므로 미리 결과값의 signbit를 결정하고 시작했다. 또한 특이한 상황들을 미리 처리해주었다.
곱셈에서 frac부분은 frac_a와 frac_b 각각에 leading1 을 추가한 값들의 곱으로 frac_result에 저장하였다. 그리고
결과값의 exp는 a의 exp부분과 b의 exp부분의 합에 15를 뺀 값이 될 것이다. 하지만 이는 임시이고, frac값의 결
과에 따라서 exp는 변경이 될 것이다. 이때 exp부분에 추가되는 값이 있는지 알아보기 위한 반복문을 작성하였
다. frac_result에 2^(20,21,22…)을 나눈값이 1인지 아닌지에 따라 지수부가 결정이 되었다. 이 때 나누어지는 2의
지수부가 20부터 시작하는 이유는, 사실상 실제 계산에서는 지수부를 제외하고, 1.xxxx 곱하기 1.xxxx 식으로 진행
이 되는데, 곱해지면 총 20자리의 소수부가 나오기 떄문이다. 따라서 20자리의 소수부를 제외하고 정수부만 계산
하기 위해 2^20 부터 지수를 시작해서 점차 늘려가며 최종 결과값의 exp를 결정할 수 있었다. 이 때 마찬가지로
마지막 10비트는 버려져야 할 것이므로, rounding변수에 추가시킨다. 이때, 곱해지면서 새롭게 exp_result가 하나
증가할 수도 있으므로, rounding변수가 달라질 수 있음에도 유의한다. 추가된 exp bit 만큼 또 오른쪽으로 shift
해야하므로 그 버려질 수 있는 비트 하나를 rounding의 변수에 맞게 값을 변경하여 rounding변수에 추가시키고,
round to even을 진행하며 추가된 exp bit만큼 frac_result를 오른쪽으로 shift한다. 마지막에는 leading1을 빼는
과정을 거친다. 마지막은 특수한 상황의 경우들이다.

## sfp2bits 함수
bits 문자열을 반환해야하므로 malloc 함수로 char배열을 동적할당 해준다.
이때 모든 배열원소들을 ‘0’으로 초기화 해주고, 매개변수로 들어온 sfp값을 2^15(idx)부터 나누기 시작하면서 비
트가 1인 위치를 찾는다. idx값을 활용하여, for문을 돌린다. 이때, sfp값들을 계속해서 2의 지수들로 나누면서 그
값들을 배열의 원소들로 알맞은 위치에 저장한다. 이때 아스키코드로 변환하는 것에 유의하며 진행한다.

## sfp_comp 함수
먼저 세개의 대소관계 문자열을 선언한다.
그 후에 예외사항들을 처리한다.
비교는 다소 쉬운게, a와 b의 부호를 알고있으면, a의 b의 부호가 다를 때, 대소관계는 결정된다.
고려해야할 부분은 a와 b의 부호가 같을 때이다. 부호가 같으면 exp의 크기비교로 진행하면 된다. 만약 지수마저
같다면 frac의 크기로 비교하면 된다. 각각의 경우에 따라 알맞은 대소관계 문자열을 반환한다.
